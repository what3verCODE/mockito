/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class MocksController {
  /**
   * Create a new controller manager
   *
   * @param collectionsPath - Path or glob pattern to collections file(s)
   * @param routesPath - Path or glob pattern to routes file(s)
   * @param defaultCollection - Optional default collection ID
   */
  constructor(collectionsPath: string, routesPath: string, defaultCollection?: string | undefined | null)
  /** Apply a collection by ID */
  useCollection(collectionId: string): void
  /**
   * Apply specific HTTP routes without changing the entire collection.
   *
   * This method allows dynamic route switching by:
   * - Resolving provided route references (`route:preset:variant`)
   * - Merging them with existing active routes
   * - Overriding routes with the same route ID
   *
   * @param routes - Array of route reference strings in format `route_id:preset_id:variant_id`
   * @throws Error if route, preset, or variant not found
   * @throws Error if route is a WebSocket route (use useSocket instead)
   */
  useRoutes(routes: Array<string>): void
  /**
   * Apply specific WebSocket routes without changing the entire collection.
   *
   * This method allows dynamic WebSocket route switching by:
   * - Resolving provided route references (`route:preset:variant`)
   * - Merging them with existing active routes
   * - Overriding routes with the same route ID
   *
   * @param routes - Array of route reference strings in format `route_id:preset_id:variant_id`
   * @throws Error if route, preset, or variant not found
   * @throws Error if route is not a WebSocket route (use useRoutes instead)
   */
  useSocket(routes: Array<string>): void
  /** Get current collection ID */
  get currentCollection(): string | null
  /** Get all active routes (HTTP + WS) */
  getActiveRoutes(): Array<ActiveRoute>
}

/** Mocks Manager class */
export declare class MocksManager {
  /**
   * Create a new mocks manager
   *
   * @param collectionsPath - Path or glob pattern to collections file(s)
   * @param routesPath - Path or glob pattern to routes file(s)
   * @param basePath - Optional base directory for resolving relative paths
   */
  constructor(collectionsPath: string, routesPath: string)
  /** Resolve collection with inheritance and return active routes */
  resolveCollection(collectionId: string): Array<ActiveRoute>
}

export interface ActiveRoute {
  route: Route
  preset: Preset
  variant: Variant
}

/** Collection of routes */
export interface Collection {
  id: string
  from?: string
  routes: Array<string>
}

/** HTTP method for route matching */
export declare const enum HttpMethod {
  Get = 0,
  Post = 1,
  Put = 2,
  Patch = 3,
  Delete = 4,
  Head = 5,
  Options = 6
}

/** Request matching preset */
export interface Preset {
  id: string
  variants: Array<Variant>
  /** Headers to match (can be an object or expression string like "${headers.myheader == 1}") */
  headers?: any
  /** Query parameters to match (can be an object or expression string like "${query.page == '1'}") */
  query?: any
  params?: Record<string, string>
  /** Payload to match (can be any JSON value or expression string like "${payload.items[0].id == 5}") */
  payload?: any
}

/** Route definition */
export interface Route {
  id: string
  url: string
  transport: Transport
  method?: HttpMethod
  presets: Array<Preset>
}

/** Transport type for route matching */
export declare const enum Transport {
  Http = 0,
  WebSocket = 1
}

/** Response variant */
export interface Variant {
  id: string
  status?: number
  headers?: Record<string, string>
  body?: any
}

/** Library version */
export declare function version(): string
